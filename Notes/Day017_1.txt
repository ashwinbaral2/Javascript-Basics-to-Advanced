Date:  Dec 18, 2025 - thu

TERMINOLOGIES:
============================================================================

1. Synchronous functions:
---------------------
 Those functions that does code execution line by line turn-wise.
 Each instructions waits for its previous instruction to complete execution.

for example;
console.log('task 1'); ---> first executed
console.log('task2');  ---> second executed
console.log('task3');  ---> third executed
==============================================================================

2. Asynchronous Functions:
-----------------------
    Those functions that get executed regardless of which order it is kept in
    they dont wait for their turn in the line ...they are executed regardless of the order
    think of a code line that fetches data from other sites that may take 2 3 sec causing 
    delay in code execution and the data is not even required to run next line of code.

 Analogy: Daraz bata saman order garesi we do our day to day thing and not just wait for delivery

example: setTimeout() ---> Asynchronous function by default.
Divided into following: callback functions, promises and await.

Callback functions 
--------------------
 A function that is passed as an argument to another function.

function wakeup(callback){
    console.log("I woke up at 5 AM.")
    callback();
}
function brushTeeth(){
    console.log("I have brushed my teeth");
}
wakeup(brushTeeth);
//I woke up at 5 AM.
//I have brushed my teeth.


The event loop continuously checks whether the call stack is empty.
If it is, the event loop takes the next callback from a queue (FIFO)
and pushes it onto the call stack (which executes functions LIFO).


Function calls push onto the call stack directly.
The event loop only pushes callbacks from queues when the stack is empty.


When functions depend on each other synchronously, they are stacked directly
 in the call stack in LIFO order and execute accordingly.
When asynchronous callbacks are involved, they are placed in a queue, 
 and the event loop moves them to the call stack only after the call stack becomes empty.
 Once that callback finishes, the stack clears again and the event loop may move the next queued task.

The call stack handles “who calls whom.”
The event loop handles “when waiting code is allowed to run.”