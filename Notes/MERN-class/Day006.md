# ğŸ“… MERN CLASS â€” DAY 006

**Date: Dec 03, 2025 (Wednesday)**  
**JavaScript Evolution Timeline**

---

## ğŸŸ¢ 1ï¸âƒ£ JAVASCRIPT EVOLUTION

**ğŸ“Œ MODERN JAVASCRIPT:**

Modern JS â†’ ES6+ (ECMAScript 2015 onwards)

**ğŸ”· JAVASCRIPT TIMELINE:**

| Year | Technology | What Happened |
|------|----------- |---------------|
| 1995 | JavaScript | Born at Netscape in 10 days |
| 1997 | ECMAScript | JS gets standardized |
| 2005 | AJAX       | Modern dynamic web begins |
| 2009 | Node.js    | JS escapes the browser |
| 2010 | AngularJS  | Google introduces massive MVC framework |
| 2013 | React      | Component-based UI revolution |
| 2014 | Vue.js     | Simplified, community-driven alternative |
| 2020 | Deno       | Node.js creator fixes his "mistakes" |
| 2022 | Bun        | Everything should be fast, integrated 

---

## ğŸŸ¢ 2ï¸âƒ£ LEARNING TASKS

**ğŸ“Œ FREECODECAMP PRACTICE:**

Practice on FreeCodeCamp to master the basics.

**ğŸ¯ TASK REQUIREMENT:**

- Get to **Level 5**
- Minimum **5 questions** in each task

---

## ğŸŸ¢ 3ï¸âƒ£ BIG O NOTATION

**ğŸ“Œ WHAT IS BIG O?**

A way to analyze algorithm efficiency by measuring time/space complexity as input grows.

**ğŸ”· BIG O COMPLEXITY CHART:**

| Big O | Notation | Real-life Analogy | Example |
|-------|----------|-------------------|---------|
| O(1) | Constant | Unlocking phone with FaceID | `arr[0]` |
| O(log n) | Logarithmic | Guessing number by halving range | Binary search |
| O(n) | Linear | Searching for pen in drawer | `for` loop over array |
| O(n log n) | Linearithmic | Sorting clothes by dividing piles | Merge sort, Quick sort |
| O(nÂ²) | Quadratic | Matching all socks in laundry | Nested `for` loops |
| O(2â¿) | Exponential | Overthinking meal choices | Naive recursive Fibonacci |
| O(n!) | Factorial | Every seating arrangement for friends | All permutations |

---

## ğŸŸ¢ 4ï¸âƒ£ BIG O CODE EXAMPLES

**ğŸ“Œ COMMON PATTERNS:**

**O(1) - Constant Time:**
```javascript
arr[5];  // Access any index instantly
```

**O(log n) - Logarithmic:**
```javascript
binarySearch(sortedArr, x);  // Halve problem each step
```

**O(n) - Linear:**
```javascript
for(let i=0; i<arr.length; i++) {
  console.log(arr[i]);  // Touch every element once
}
```

**O(n log n) - Linearithmic:**
```javascript
arr.sort((a,b) => a-b);  // Efficient sort: divide + conquer
```

**O(nÂ²) - Quadratic:**
```javascript
for(let i=0; i<arr.length; i++) {
  for(let j=0; j<arr.length; j++) {
    console.log(i, j);  // Nested loops, check every pair
  }
}
```

**O(2â¿) - Exponential:**
```javascript
function fib(n) {
  return n <= 1 ? n : fib(n-1) + fib(n-2);  // Every step branches into 2
}
```

**O(n!) - Factorial:**
```javascript
function permute(arr) {
  if(arr.length <= 1) return [arr];
  let res = [];
  for(let i=0; i<arr.length; i++) {
    let rest = arr.slice(0,i).concat(arr.slice(i+1));
    for(let p of permute(rest)) {
      res.push([arr[i], ...p]);
    }
  }
  return res;  // All permutations
}
```

---

## ğŸ¯ KEY TAKEAWAY

**Aim for O(n log n) or better!** Avoid O(nÂ²) and exponential algorithms for large datasets.
