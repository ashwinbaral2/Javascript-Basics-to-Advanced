// ===============================
// LEVEL 6 OBJECT CHALLENGES
// Day 4 – Coding Challenge
// ===============================

/*
Q1.
Create a function `createNullObject()`
that behaves like a normal object but has NO prototype.
*/

// Hint: Object.create(null)


/*
Q2.
Write `inherit(child, parent)`
that sets up prototypal inheritance WITHOUT using class or extends.
*/

// Hint: constructor + prototype chain.


/*
Q3.
Create a function `deepCloneWithDescriptors(obj)`
that clones an object INCLUDING property descriptors.
*/

// Hint: getOwnPropertyDescriptors exists for a reason.


/*
Q4.
Write `makeImmutable(obj)`
that deeply freezes an object AND throws error on mutation attempt.
*/

// Hint: Combine freeze with strict mode or Proxy.


/*
Q5.
Create a function `lazyObject(factory)`
that only creates properties when they are first accessed.
*/

// Hint: Proxy again. Yes, again.


/*
Q6.
Implement `validateShape(obj, schema)`
where schema defines expected keys and their types.
*/

// Example schema:
// { name: "string", age: "number" }

// Hint: typeof isn’t enough for arrays & null.


/*
Q7.
Design `serializeObject(obj)`
that converts functions into strings
and restores them back using `deserializeObject`.
*/

// Hint: JSON won’t save you. eval might—but tread carefully.







/*
Q2.
Write a function `mergeObjectsStrict(a, b)`
that merges two objects BUT throws an error if any key exists in both.
*/

// Hint: Object.keys + includes is enough.


/*
Q3.
Given an object with methods, make a function `detachMethod(obj, methodName)`
that returns the method but keeps `this` bound correctly.
*/

// Hint: bind is your old friend.


/*
Q4.
Create a function `countPropertyAccess(obj)`
that returns a proxy which counts how many times each property is accessed.
*/

// Hint: Proxy + get trap.


/*
Q5.
Write `removeFalsyDeep(obj)`
that removes falsy values from an object deeply (nested objects too).
*/

// Hint: typeof null is a liar.


/*
Q6.
Given an object, write `lockStructure(obj)`
which prevents adding or deleting properties
but still allows updating existing values.
*/

// Hint: seal ≠ freeze.


/*
Q7.
Create a function `objectDiff(obj1, obj2)`
that returns keys whose values differ (shallow comparison).
*/

// Hint: Compare both directions, not just one.
